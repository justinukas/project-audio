#include "include\main.h"

bool isPlaying = false;        // isPlaying boolean. Needs implementation fixing cause ts is voodoo
float volumeMultiplier = 0.5f; // volume setting with default
std::mutex audioMutex;         // use this when reading frames outside of data callback in any way (stuff like seeking)

std::thread playlistThread;    // seperate thread for playlists

void data_callback(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount) {
    
    std::lock_guard<std::mutex> lock(audioMutex);

    // DEFINE CURRENTLY LOADED DECODER AND CHECK IF IT EXISTS OR NOT
    ma_decoder* pDecoder = static_cast<ma_decoder*>(pDevice->pUserData);
    if (pDecoder == NULL || !isPlaying) return;
    
    // --------- END OF PLAYBACK CHECK ---------- 
    ma_uint64 audioFramesRead = 0;
    ma_decoder_read_pcm_frames(pDecoder, pOutput, frameCount, &audioFramesRead);

    if (audioFramesRead < frameCount) {
        isPlaying = false;
        std::cout << "End of playback\n";
    }

    // ---------- VOLUME CONTROL --------------
    // 
    // some voodoo shit for volume control from this github issue
    // https://github.com/mackron/miniaudio/issues/26#issuecomment-406415191
    float* samples = static_cast<float*>(pOutput);
    ma_uint32 channelCount = pDecoder->outputChannels;
    ma_uint64 totalSamples = audioFramesRead * channelCount;
    for (size_t i = 0; i < totalSamples; i++) {
        samples[i] *= volumeMultiplier;
    }
}


void deviceCleanup(ma_decoder& decoder, ma_device& device) {
    if (ma_device_is_started(&device)) {
        ma_device_uninit(&device);
        ma_decoder_uninit(&decoder);
    }
}

void seekToFrame(ma_decoder& decoder, ma_uint64 frame) {
    std::lock_guard<std::mutex> lock(audioMutex);
    ma_decoder_seek_to_pcm_frame(&decoder, frame);
}

void cmnd_help() {
    std::cout
        << "Available commands:\n"
        << "help\n"
        << "load <file_directory>  -loads the audio file (only .wav, .mp3, and .flac are supported)\n"
        << "                       (HINT: you can drag and drop your file into the CLI!\n"
        << "play                   -start or resume playback\n"
        << "stop                   -stop playback\n"
        << "pause                  -pause playback\n"
        << "seek                   -seek to a specific timestamp. Syntax: mm:ss\n"
        << "volume                 -set volume from 0-100\n"
        << "time                   -get how much of the song has elapsed\n"
        << "read                   -read a directory for multiple audio files and play them sequentially\n"
        << "exit                   -exit program\n"
        << "\nDEBUG COMMANDS:\n"
        << "isplaying              -check if audio is playing\n";
}

void configureDevice(ma_decoder& decoder, ma_device_config& deviceConfig) {

    deviceConfig = ma_device_config_init(ma_device_type_playback);
    deviceConfig.playback.format = decoder.outputFormat;
    deviceConfig.playback.channels = decoder.outputChannels;
    deviceConfig.sampleRate = decoder.outputSampleRate;
    deviceConfig.dataCallback = data_callback;
    deviceConfig.pUserData = &decoder;
}

void cmnd_load(std::string& strAudioPath, ma_result& result, ma_decoder& decoder, ma_device_config& deviceConfig, ma_device& device) {

    if (strAudioPath.empty()) {
        std::cout << "No file path provided\n";
        return;
    }

    // removes the quotation marks from the ends of the input string if any are present
    strAudioPath.erase(remove(strAudioPath.begin(), strAudioPath.end(), '\"'), strAudioPath.end());
    const char* audioPath = strAudioPath.c_str();

    result = ma_decoder_init_file(audioPath, NULL, &decoder);

    if (result != MA_SUCCESS) {
        std::cout << "Could not load file: " << audioPath << "\n";
        return;
    }

    configureDevice(decoder, deviceConfig);

    std::cout << "File " << audioPath << " loaded successfuly!\n";
}

void getTime(ma_decoder& decoder, int& seconds, int& minutes, std::string type) {
    std::lock_guard<std::mutex> lock(audioMutex);

    ma_uint64 frames = 0;
    if (type == "elapsed") {
        ma_decoder_get_cursor_in_pcm_frames(&decoder, &frames);
    }
    else if (type == "length") {
        ma_decoder_get_length_in_pcm_frames(&decoder, &frames);
    }

    if (decoder.outputSampleRate != 0) {
        seconds = static_cast<int>(frames) / decoder.outputSampleRate;
    }
    minutes = seconds / 60;
    seconds -= minutes * 60;
}


void cmnd_play(ma_result& result, ma_decoder& decoder, ma_device_config& deviceConfig, ma_device& device) {
    // seek to beginning
    if (isPlaying) {
        seekToFrame(decoder, 0);
        return;
    }

    if (result != MA_SUCCESS) {
        std::cout << "Please load a file using 'load <file_path>' first!\n";
        return;
    }

    // these ifs below are if statements and also function calls at the same time somehow
    if (ma_device_init(NULL, &deviceConfig, &device) != MA_SUCCESS) {
        std::cout << "Failed to open playback device\n";
        ma_decoder_uninit(&decoder);
        return;
    }
    if (ma_device_start(&device) != MA_SUCCESS) {
        std::cout << "Failed to start playback device\n";
        deviceCleanup(decoder, device);
        return;
    }

    isPlaying = true;
    std::cout << "Playing... \n";

    int seconds, minutes;
    getTime(decoder, seconds, minutes, "length");
    std::cout << "Song length: [" << std::setfill('0') << std::setw(2) << minutes << ':' << std::setfill('0') << std::setw(2) << seconds << ']' << '\n';
}

void cmnd_stopPause(std::string cmnd, ma_decoder& decoder, ma_device& device) {
    if (!isPlaying) {
        std::cout << "Nothing is playing\n";
        return;
    }


    if (isPlaying) {
        ma_device_stop(&device);
        isPlaying = false;
    }

    if (cmnd == "stop") {
        seekToFrame(decoder, 0);
        std::cout << "Stopped and rewound\n";
    }
    else if (cmnd == "pause") {
        std::cout << "Paused\n";
    }
}

void cmnd_seek(std::string strLength, ma_decoder& decoder, ma_device& device) {
    if (!isPlaying) {
        std::cout << "Nothing is currently playing\n";
        return;
    }

    // check for syntax 'xx:xx'
    if (!std::regex_match(strLength, (std::regex)("^\\d{2}:\\d{2}$"))) {
        std::cout << "Invalid syntax\n";
        return;
    }

    int seconds, minutes, totalLengthSeconds;
    char colon;

    std::istringstream ss(strLength);
    ss >> minutes >> colon >> seconds;

    totalLengthSeconds = minutes * 60 + seconds;

    ma_uint64 seekFrame = static_cast<ma_uint64>(totalLengthSeconds) * decoder.outputSampleRate;;

    seekToFrame(decoder, seekFrame);
}


bool validateVolumeInput(std::string inputVolume, float& outVolume) {
    try {
        int vol = std::stoi(inputVolume);

        if (vol < 0 || vol > 100) {
            return false;
        }
        outVolume = vol / 100.0f; // convert % to decimal
        return true;
    }
    catch (...) {
        return false;
    }
}

void cmnd_volume(std::string inputVolume, ma_decoder& decoder, ma_device& device) {
    float newVolume;
    if (!validateVolumeInput(inputVolume, newVolume)) {
        std::cout << "Please input a number from 0-100\n";
        return;
    }
    volumeMultiplier = newVolume;
}

void cmnd_elapsedTime(ma_decoder& decoder) {
    if (!isPlaying) {
        return;
    }

    int seconds, minutes;
    getTime(decoder, seconds, minutes, "elapsed");

    std::cout << '[' << std::setfill('0') << std::setw(2) << minutes << ':' << std::setfill('0') << std::setw(2) << seconds << ']' << '\n';
}



void cmnd_playlist(std::string parameter, std::string& directory, ma_result& result, ma_decoder& decoder, ma_device_config& deviceConfig, ma_device& device) {
    directory.erase(remove(directory.begin(), directory.end(), '\"'), directory.end());
    if (parameter == "make") {
        std::vector<std::string> songPaths;

        for (const auto& entry : std::filesystem::directory_iterator(directory)) {
            auto extension = entry.path().extension();
            if (extension == ".mp3" || extension == ".wav" || extension == ".flac") {
                std::cout << entry.path() << std::endl;
                songPaths.push_back(entry.path().string());
            }
        }
        std::ofstream out(directory+"/playlist.txt");
        for (int i = 0; i < songPaths.size(); i++) {
            out << i + 1 << ' ' << songPaths[i] << std::endl;
        }
        out.close();
    }

    else if (parameter == "play") {
        std::ifstream in(directory+"/playlist.txt");
        std::string line;
        std::vector<std::string> playlist;
        while (std::getline(in, line))
        {
            std::string x;
            std::string path;

            std::stringstream ss(line);
            std::getline(ss, x, ' ');
            std::getline(ss, path);

            playlist.push_back(path);
        }

        for (int i = 0; i < playlist.size(); i++) {
            cmnd_load(playlist[i], result, decoder, deviceConfig, device);
            cmnd_play(result, decoder, deviceConfig, device);
            while (isPlaying) {
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
            }
        }
    }
}

void cmnd_skip(ma_decoder& decoder) {
    ma_uint64 totalFrames = 0;
    ma_decoder_get_length_in_pcm_frames(&decoder, &totalFrames);

    std::cout << "Total frames: " << totalFrames << "\n";
    seekToFrame(decoder, totalFrames);
}


int main() {
    ma_result result;
    ma_decoder decoder;
    ma_device_config deviceConfig;
    ma_device device;

    std::cout << "Welcome to the gaming time audio player TM! Type 'help' for a list of commands\n";
    // while loop for user input
    while (true)
    {
        std::string userInput, cmnd, parameter, parameter2;

        std::getline(std::cin, userInput);
        std::stringstream ss(userInput);

        // split userinput into command and the paramater of said command
        std::getline(ss, cmnd, ' ');
        std::getline(ss, parameter, ' ');
        std::getline(ss, parameter2);

        if (cmnd == "help") cmnd_help();
        else if (cmnd == "load") cmnd_load(parameter, result, decoder, deviceConfig, device);
        else if (cmnd == "play") cmnd_play(result, decoder, deviceConfig, device);
        else if (cmnd == "stop" || cmnd == "pause") cmnd_stopPause(cmnd, decoder, device);
        else if (cmnd == "seek") cmnd_seek(parameter, decoder, device);
        else if (cmnd == "volume") cmnd_volume(parameter, decoder, device);
        else if (cmnd == "time") cmnd_elapsedTime(decoder);
        else if (cmnd == "playlist") cmnd_playlist(parameter, parameter2, result, decoder, deviceConfig, device);
        else if (cmnd == "skip") cmnd_skip(decoder);
        else if (cmnd == "exit") break;
        else if (cmnd == "isplaying") std::cout << std::boolalpha << isPlaying << "\n";

        else std::cout << "Unknown command. Type 'help' for available commands\n";
    }
    std::cout << "Exiting... ";

    if (isPlaying) {
        ma_device_stop(&device);
        isPlaying = false;
    }
    deviceCleanup(decoder, device);

    return 0;
}
